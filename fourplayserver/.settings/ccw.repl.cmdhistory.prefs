cmdhistory=[";; Switching to fourplayserver.java-interop namespace" "(row-of-n? [1 1 1 1])" "(defn row-of-n?\\n  [row]\\n  (some \#(or (\= (repeat n 1) %) (\= (repeat n -1) %)) (partition n 1 row)))" "(row-of-n? [1 1 1 1])" "(row-of-n? [1 1 1 -1])" "(defn row-of-n?\\n  [row]\\n  (find-first \#(or (\= (repeat n 1) %) (\= (repeat n -1) %)) (partition n 1 row)))" "(defn get-board-state\\n  [board]\\n  0)" "(row-of-n? [1 1 1 -1])" "(row-of-n? [1 1 1 1])" "(defn row-of-n?\\n  [row]\\n  (first (first (drop-while \#(or (\= (repeat n 1) %) (\= (repeat n -1) %)) (partition n 1 row)))))" "(row-of-n? [1 1 1 1])" "(row-of-n? [1 1 1 -1])" "(defn row-of-n?\\n  [row]\\n  (first (first (drop-while \#(not (or (\= (repeat n 1) %) (\= (repeat n -1) %))) (partition n 1 row)))))" "(row-of-n? [1 1 1 -1])" "(row-of-n? [1 1 1 1])" "(row-of-n? [1 1 1 -1 -1 -1 -1])" "(partition cols cols (\:state empty-board))" "(partition cols cols [1,1,1,1,0,0,0,-1,-1,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])" "(row-of-n? *1)" "(range 6)" "(doc partition)" "(map (fn [i] (mapcat \#(get % i) rows)) (range 7))" "(defn get-board-state\\n  [board]\\n  (let [rows (partition cols cols (\:state board))\\n        row-result (first (remove nil? (map row-of-n? rows)))]\\n    (if (nil? row-result) \\n      (let [cols (map (fn [i] (mapcat \#(get % i) rows)) (range cols))\\n            col-result (first (remove nil? (map row-of-n? rows)))]\\n        (if (nil? col-result) 0 col-result))\\n      row-result)))" "(def rows (partition cols cols (\:state empty-board))" "(def rows (partition cols cols (\:state empty-board)))" "rows" "(map (fn [i] (mapcat \#(get % i) rows)) (range 7))" "(map (fn [i] (mapcat \#(get (vec %) i) rows)) (range 7))" "(map (fn [i] (mapcat \#(get % i) (map vec rows))) (range 7))" "(mpa vec rows)" "(mpa vector rows)" "(map vec rows)" "(map (fn [i] (mapcat \#(get % i) (map vec rows))) (range 7))" "(map vec rows)" "(map \#(get % 1) (map vec rows))" "(defn get-board-state\\n  [board]\\n  (let [rows (partition cols cols (\:state board))\\n        row-result (first (remove nil? (map row-of-n? rows)))]\\n    (if (nil? row-result) \\n      (let [cols (map (fn [i] (map \#(get % i) rows)) (range cols))\\n            col-result (first (remove nil? (map row-of-n? rows)))]\\n        (if (nil? col-result) 0 col-result))\\n      row-result)))" "(map (fn [i] (map \#(get % i) rows)) (range cols))" "rows" "(map (fn [i] (println i) (map \#(get % i) rows)) (range cols))" "(map (fn [i] (map \#(get % i) rows)) (range cols))" "(map \#(get % 0) rows)" "rows" "(defn get-board-state\\n  [board]\\n  (let [rows (partition cols cols (\:state board))\\n        row-result (first (remove nil? (map row-of-n? rows)))]\\n    (if (nil? row-result) \\n      (let [cols (map (fn [i] (map \#(get (vec %) i) rows)) (range cols))\\n            col-result (first (remove nil? (map row-of-n? rows)))]\\n        (if (nil? col-result) 0 col-result))\\n      row-result)))" "(map (fn [i] (map \#(get (vec %) i) rows)) (range cols))" "(def board [1,-1,0,0,0,0,0,1,-1,0,0,0,0,0,1,-1,0,0,0,0,0,1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])" "(def rows (partition cols cols (\:state board)))" "(map (fn [i] (map \#(get (vec %) i) rows)) (range cols))" "rows" "(def rows (partition cols cols board))" "rows" "(map (fn [i] (map \#(get (vec %) i) rows)) (range cols))" "(conj [] 1)" "(dec (* rows cols)" "(dec (* rows cols))" "(into \#{} [1] [1])" "(def board [1,-1,-1,1,-1,0,0,0,0,1,-1,-1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])" "(get-positive-diagonals board)" "(defn get-positive-diagonals\\n  [board]\\n  (let [bottom-row (into \#{} (range cols))\\n        left-col (map \#(* cols %) (range rows))\\n        start-positions (into bottom-row left-col)]\\n    (map \#(get-diagonal board % (inc cols)) start-positions)))" "(defn get-diagonal\\n  [board start delta]\\n  (loop [pos start\\n         diag []]\\n    (if (> pos (dec (* rows cols)))\\n      diag\\n      (recur (+ pos delta) (conj diag (get board pos))))))" "(defn get-positive-diagonals\\n  [board]\\n  (let [bottom-row (into \#{} (range cols))\\n        left-col (map \#(* cols %) (range rows))\\n        start-positions (into bottom-row left-col)]\\n    (map \#(get-diagonal board % (inc cols)) start-positions)))" "(defn get-board-state\\n  [board]\\n  (let [rows (partition cols cols (\:state board))\\n        row-result (first (remove nil? (map row-of-n? rows)))]\\n    (if (nil? row-result) \\n      (let [cols (map (fn [i] (map \#(get (vec %) i) rows)) (range cols))\\n            col-result (first (remove nil? (map row-of-n? cols)))]\\n        (if (nil? col-result) \\n          (let [pos-diags (get-positive-diagonals board)\\n                pd-result (first (remove nil? (map row-of-n? pos-diags)))]\\n            (if (nil? pd-result) 0 pd-result)) \\n          col-result))\\n      row-result)))" "(get-positive-diagonals board)" "(defn get-diagonal\\n  [board start delta]\\n  (println start)\\n  (loop [pos start\\n         diag []]\\n    (if (> pos (dec (* rows cols)))\\n      diag\\n      (recur (+ pos delta) (conj diag (get board pos))))))" "(get-positive-diagonals board)" "(defn get-positive-diagonals\\n  [board]\\n  (let [bottom-row (into \#{} (range cols))\\n        left-col (map \#(* cols %) (range rows))\\n        start-positions (into bottom-row left-col)]\\n    (println start-positions)\\n    (map \#(get-diagonal board % (inc cols)) start-positions)))" "(get-positive-diagonals board)" "into \#{} (range cols)" "(into \#{} (range cols)" "(into \#{} (range cols))" "(map \#(* cols %) (range rows))" ";; Switching to fourplayserver.java-interop namespace" "(map \#(* cols %) (range rows))" "(def board [1,-1,-1,1,-1,0,0,0,0,1,-1,-1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])" "(get-positive-diagonals board)" "(first (remove nil? (map row-of-n? *1)))" "(def board [1,-1,-1,1,0,0,0,-1,-1,-1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0](" "(def board [1,-1,-1,1,0,0,0,-1,-1,-1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])" "(defn get-negative-diagonals\\n  [board]\\n  (let [bottom-row (into \#{} (range cols))\\n        right-col (map \#(+ (dec cols) (* cols %)) (range rows))\\n        start-positions (into bottom-row left-col)]\\n    (println start-positions)\\n    (map \#(get-diagonal board % (* -1 (inc cols))) start-positions)))" "(defn get-negative-diagonals\\n  [board]\\n  (let [bottom-row (into \#{} (range cols))\\n        right-col (map \#(+ (dec cols) (* cols %)) (range rows))\\n        start-positions (into bottom-row right-col)]\\n    (println start-positions)\\n    (map \#(get-diagonal board % (* -1 (inc cols))) start-positions)))" "(get-negative-diagonals board)" ";; Switching to fourplayserver.java-interop namespace" "(< -1 0)" "(def board [1,1,1,-1,0,0,1,1,-1,-1,-1,0,0,0,0,1,1,-1,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])" "(get-negative-diagonals board)" "(last *1)" "(get-negative-diagonals board)" "(defn get-negative-diagonals\\n  [board]\\n  (let [bottom-row (into \#{} (range cols))\\n        right-col (map \#(+ (dec cols) (* cols %)) (range rows))\\n        start-positions (into bottom-row right-col)]\\n    (println start-positions)\\n    (map \#(get-diagonal board % (dec cols)) start-positions)))" "(get-negative-diagonals board)" ";; Switching to fourplayserver.websocket namespace" "(swap\! connections conj 4)" "(defn connections (atom []))" "(def connections (atom []))" "(swap\! connections conj 4)" "(Board. [])" "(Board. [-1 -1 -1] 3 3)" ";; Switching to fourplayserver.java-interop namespace" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'fourplayserver.java-interop)))" "(Board. [-1 -1 -1] 3 3)" "(Board. [-1 1 -1 1 -1 1 -1 1 1\\n         ] 3 3)" "(Board. (int-array [-1 1 -1 1 -1 1 -1 1 1]) 3 3)" "(get-board-state *1)" "(get-board-state {\:state *1})" "(get-board-state {\:state (Board. (int-array [-1 1 -1 1 -1 1 -1 1 1]) 3 3)})" "(get-board-state {\:state (Board. (int-array [-1 1 -1 1 -1 1 -1 1 0\\n                                             ]) 3 3)})" "(make-move  {\:state (Board. (int-array [-1 1 -1 1 -1 1 -1 1 0]) 3 3)} 2)" "(get-board-state (make-move  {\:state (Board. (int-array [-1 1 -1 1 -1 1 -1 1 0]) 3 3)} 2))" "(get-board-state {\:state (Board. (int-array [-1 1 -1 1 -1 1 -1 1 0\\n                                             ]) 3 3)})" "(doc rand)" "(doc alter)" "(doc update-in)" "(combo/combinations [1 2 3 4 5 6 7] 2)" "(in-ns 'fourplayserver.tournament)\\n(ns fourplayserver.tournament\\n  (\:require [cheshire.core \:as json]\\n            [fourplayserver.java-interop \:as board]\\n            [fourplayserver.models.socket-connections \:refer [connections]]\\n            [clojure.math.combinatorics \:as combo]))\\n(in-ns 'fourplayserver.java-interop)" "(combo/combinations [1 2 3 4 5 6 7] 2)" ";; Switching to fourplayserver.tournament namespace" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'fourplayserver.tournament)))" "(combo/combinations [1 2 3 4 5 6 7] 2)"]
eclipse.preferences.version=1
